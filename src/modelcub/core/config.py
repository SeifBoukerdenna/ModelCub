"""
ModelCub configuration management.

Handles .modelcub/config.yaml with full project settings.
"""
from __future__ import annotations
from dataclasses import dataclass, asdict
from datetime import datetime
from pathlib import Path
from typing import Optional


@dataclass
class ProjectConfig:
    """Project metadata configuration."""
    name: str = "unnamed"
    created: str = ""
    version: str = "1.0.0"


@dataclass
class DefaultsConfig:
    """Default training/inference settings."""
    device: str = "cpu"  # Will be auto-detected at project creation
    batch_size: int = 16
    image_size: int = 640
    workers: int = 8
    format: str = "yolo"


@dataclass
class PathsConfig:
    """Project directory paths."""
    data: str = "data"
    runs: str = "runs"
    reports: str = "reports"


@dataclass
class LoggingConfig:
    """Logging configuration."""
    level: str = "INFO"
    format: str = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"
    handlers: dict = None

    def __post_init__(self):
        if self.handlers is None:
            self.handlers = {
                "console": {"enabled": True, "level": "INFO"},
                "file": {
                    "enabled": True,
                    "level": "DEBUG",
                    "path": ".modelcub/logs/modelcub.log",
                    "max_bytes": 10485760,
                    "backup_count": 5
                }
            }

@dataclass
class Config:
    """Complete ModelCub project configuration."""
    project: ProjectConfig
    defaults: DefaultsConfig
    paths: PathsConfig
    logging: LoggingConfig = None

    def __post_init__(self):
        if self.logging is None:
            self.logging = LoggingConfig()

    def to_dict(self) -> dict:
        """Convert to dictionary for YAML serialization."""
        return {
            "project": asdict(self.project),
            "defaults": asdict(self.defaults),
            "paths": asdict(self.paths),
            "logging": asdict(self.logging)
        }

    @classmethod
    def from_dict(cls, data: dict) -> Config:
        """Load from dictionary."""
        project_data = data.get("project", {})
        defaults_data = data.get("defaults", {})
        paths_data = data.get("paths", {})

        return cls(
            project=ProjectConfig(**project_data) if project_data else ProjectConfig(),
            defaults=DefaultsConfig(**defaults_data) if defaults_data else DefaultsConfig(),
            paths=PathsConfig(**paths_data) if paths_data else PathsConfig()
        )

    def to_yaml_string(self) -> str:
        """Convert to YAML format (without PyYAML dependency)."""
        lines = []

        # Warning header
        lines.append("# ⚠️  WARNING: DO NOT EDIT THIS FILE DIRECTLY!")
        lines.append("#")
        lines.append("# This file is managed by ModelCub. Editing it manually may cause issues.")
        lines.append("# Always use one of these methods to modify configuration:")
        lines.append("#")
        lines.append("#   CLI:        modelcub project config set <key> <value>")
        lines.append("#   Python SDK: project.set_config('key', value)")
        lines.append("#   Web UI:     Use the Settings page")
        lines.append("#")
        lines.append("# Example:")
        lines.append("#   modelcub project config set defaults.batch_size 32")
        lines.append("#")
        lines.append("# Manual edits to this file are NOT supported and may result in")
        lines.append("# data corruption or unexpected behavior.")
        lines.append("")
        lines.append("# ModelCub Project Configuration")
        lines.append("")

        lines.append("project:")
        lines.append(f"  name: \"{self.project.name}\"")
        lines.append(f"  created: \"{self.project.created}\"")
        lines.append(f"  version: \"{self.project.version}\"")
        lines.append("")

        lines.append("defaults:")
        lines.append(f"  device: \"{self.defaults.device}\"  # Auto-detected: cuda/mps/cpu")
        lines.append(f"  batch_size: {self.defaults.batch_size}  # Training batch size")
        lines.append(f"  image_size: {self.defaults.image_size}  # Image resolution (pixels)")
        lines.append(f"  workers: {self.defaults.workers}  # DataLoader workers")
        lines.append(f"  format: \"{self.defaults.format}\"  # Internal format (yolo)")
        lines.append("")

        lines.append("paths:")
        lines.append(f"  data: \"{self.paths.data}\"  # Dataset directory")
        lines.append(f"  runs: \"{self.paths.runs}\"  # Training outputs")
        lines.append(f"  reports: \"{self.paths.reports}\"  # Generated reports")
        lines.append("")

        return "\n".join(lines)

    @classmethod
    def from_yaml_string(cls, content: str) -> Config:
        """Parse YAML string (simple parser without PyYAML)."""
        lines = [l.strip() for l in content.split("\n") if l.strip() and not l.strip().startswith("#")]

        data = {"project": {}, "defaults": {}, "paths": {}}
        current_section = None

        for line in lines:
            if line.endswith(":") and not line.startswith(" "):
                section_name = line[:-1].strip()
                if section_name in data:
                    current_section = section_name
            elif ":" in line and current_section:
                parts = line.split(":", 1)
                if len(parts) == 2:
                    key = parts[0].strip()
                    # Remove inline comments and quotes
                    value = parts[1].split("#")[0].strip().strip('"').strip("'")

                    if value.isdigit():
                        value = int(value)
                    elif value.lower() in ("true", "false"):
                        value = value.lower() == "true"
                    elif value.replace(".", "", 1).isdigit():
                        try:
                            value = float(value)
                        except:
                            pass

                    if current_section and key:
                        data[current_section][key] = value

        return cls.from_dict(data)


def load_config(project_root: Path) -> Optional[Config]:
    """Load config from .modelcub/config.yaml."""
    config_path = project_root / ".modelcub" / "config.yaml"
    if not config_path.exists():
        return None

    content = config_path.read_text(encoding="utf-8")
    return Config.from_yaml_string(content)


def save_config(project_root: Path, config: Config) -> None:
    """Save config to .modelcub/config.yaml."""
    config_path = project_root / ".modelcub" / "config.yaml"
    config_path.parent.mkdir(parents=True, exist_ok=True)
    config_path.write_text(config.to_yaml_string(), encoding="utf-8")


def create_default_config(name: str) -> Config:
    from .hardware import detect_device
    device = detect_device()

    return Config(
        project=ProjectConfig(
            name=name,
            created=datetime.utcnow().isoformat() + "Z",
            version="1.0.0"
        ),
        defaults=DefaultsConfig(device=device, batch_size=16, image_size=640, workers=8, format="yolo"),
        paths=PathsConfig(),
        logging=LoggingConfig()
    )